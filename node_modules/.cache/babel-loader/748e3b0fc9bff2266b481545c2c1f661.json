{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport isReactNative from './isReactNative';\nimport uriToBlob from './uriToBlob';\nimport isCordova from './isCordova';\nimport readAsByteArray from './readAsByteArray';\n\nvar FileSource = /*#__PURE__*/function () {\n  // Make this.size a method\n  function FileSource(file) {\n    _classCallCheck(this, FileSource);\n\n    this._file = file;\n    this.size = file.size;\n  }\n\n  _createClass(FileSource, [{\n    key: \"slice\",\n    value: function slice(start, end) {\n      // In Apache Cordova applications, a File must be resolved using\n      // FileReader instances, see\n      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file\n      if (isCordova()) {\n        return readAsByteArray(this._file.slice(start, end));\n      }\n\n      var value = this._file.slice(start, end);\n\n      return Promise.resolve({\n        value: value\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close() {// Nothing to do here since we don't need to release any resources.\n    }\n  }]);\n\n  return FileSource;\n}();\n\nvar StreamSource = /*#__PURE__*/function () {\n  function StreamSource(reader, chunkSize) {\n    _classCallCheck(this, StreamSource);\n\n    this._chunkSize = chunkSize;\n    this._buffer = undefined;\n    this._bufferOffset = 0;\n    this._reader = reader;\n    this._done = false;\n  }\n\n  _createClass(StreamSource, [{\n    key: \"slice\",\n    value: function slice(start, end) {\n      if (start < this._bufferOffset) {\n        return Promise.reject(new Error(\"Requested data is before the reader's current offset\"));\n      }\n\n      return this._readUntilEnoughDataOrDone(start, end);\n    }\n  }, {\n    key: \"_readUntilEnoughDataOrDone\",\n    value: function _readUntilEnoughDataOrDone(start, end) {\n      var _this = this;\n\n      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);\n\n      if (this._done || hasEnoughData) {\n        var value = this._getDataFromBuffer(start, end);\n\n        var done = value == null ? this._done : false;\n        return Promise.resolve({\n          value: value,\n          done: done\n        });\n      }\n\n      return this._reader.read().then(function (_ref) {\n        var value = _ref.value,\n            done = _ref.done;\n\n        if (done) {\n          _this._done = true;\n        } else if (_this._buffer === undefined) {\n          _this._buffer = value;\n        } else {\n          _this._buffer = concat(_this._buffer, value);\n        }\n\n        return _this._readUntilEnoughDataOrDone(start, end);\n      });\n    }\n  }, {\n    key: \"_getDataFromBuffer\",\n    value: function _getDataFromBuffer(start, end) {\n      // Remove data from buffer before `start`.\n      // Data might be reread from the buffer if an upload fails, so we can only\n      // safely delete data when it comes *before* what is currently being read.\n      if (start > this._bufferOffset) {\n        this._buffer = this._buffer.slice(start - this._bufferOffset);\n        this._bufferOffset = start;\n      } // If the buffer is empty after removing old data, all data has been read.\n\n\n      var hasAllDataBeenRead = len(this._buffer) === 0;\n\n      if (this._done && hasAllDataBeenRead) {\n        return null;\n      } // We already removed data before `start`, so we just return the first\n      // chunk from the buffer.\n\n\n      return this._buffer.slice(0, end - start);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._reader.cancel) {\n        this._reader.cancel();\n      }\n    }\n  }]);\n\n  return StreamSource;\n}();\n\nfunction len(blobOrArray) {\n  if (blobOrArray === undefined) return 0;\n  if (blobOrArray.size !== undefined) return blobOrArray.size;\n  return blobOrArray.length;\n}\n/*\n  Typed arrays and blobs don't have a concat method.\n  This function helps StreamSource accumulate data to reach chunkSize.\n*/\n\n\nfunction concat(a, b) {\n  if (a.concat) {\n    // Is `a` an Array?\n    return a.concat(b);\n  }\n\n  if (a instanceof Blob) {\n    return new Blob([a, b], {\n      type: a.type\n    });\n  }\n\n  if (a.set) {\n    // Is `a` a typed array?\n    var c = new a.constructor(a.length + b.length);\n    c.set(a);\n    c.set(b, a.length);\n    return c;\n  }\n\n  throw new Error('Unknown data type');\n}\n\nvar FileReader = /*#__PURE__*/function () {\n  function FileReader() {\n    _classCallCheck(this, FileReader);\n  }\n\n  _createClass(FileReader, [{\n    key: \"openFile\",\n    value: function openFile(input, chunkSize) {\n      // In React Native, when user selects a file, instead of a File or Blob,\n      // you usually get a file object {} with a uri property that contains\n      // a local path to the file. We use XMLHttpRequest to fetch\n      // the file blob, before uploading with tus.\n      if (isReactNative() && input && typeof input.uri !== 'undefined') {\n        return uriToBlob(input.uri).then(function (blob) {\n          return new FileSource(blob);\n        })[\"catch\"](function (err) {\n          throw new Error(\"tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. \".concat(err));\n        });\n      } // Since we emulate the Blob type in our tests (not all target browsers\n      // support it), we cannot use `instanceof` for testing whether the input value\n      // can be handled. Instead, we simply check is the slice() function and the\n      // size property are available.\n\n\n      if (typeof input.slice === 'function' && typeof input.size !== 'undefined') {\n        return Promise.resolve(new FileSource(input));\n      }\n\n      if (typeof input.read === 'function') {\n        chunkSize = +chunkSize;\n\n        if (!isFinite(chunkSize)) {\n          return Promise.reject(new Error('cannot create source for stream without a finite value for the `chunkSize` option'));\n        }\n\n        return Promise.resolve(new StreamSource(input, chunkSize));\n      }\n\n      return Promise.reject(new Error('source object may only be an instance of File, Blob, or Reader in this environment'));\n    }\n  }]);\n\n  return FileReader;\n}();\n\nexport { FileReader as default };","map":{"version":3,"sources":["/home/joao/Projects/iconect_test/dropzone/node_modules/tus-js-client/lib.esm/browser/fileReader.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","isReactNative","uriToBlob","isCordova","readAsByteArray","FileSource","file","_file","size","value","slice","start","end","Promise","resolve","close","StreamSource","reader","chunkSize","_chunkSize","_buffer","undefined","_bufferOffset","_reader","_done","reject","Error","_readUntilEnoughDataOrDone","_this","hasEnoughData","len","_getDataFromBuffer","done","read","then","_ref","concat","hasAllDataBeenRead","cancel","blobOrArray","a","b","Blob","type","set","c","constructor","FileReader","openFile","input","uri","blob","err","isFinite","default"],"mappings":"AAAA,SAASA,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,IAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBd,WAAtB,EAAmCe,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBb,iBAAiB,CAACF,WAAW,CAACiB,SAAb,EAAwBF,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBd,iBAAiB,CAACF,WAAD,EAAcgB,WAAd,CAAjB;AAA6C,SAAOhB,WAAP;AAAqB;;AAEvN,OAAOkB,aAAP,MAA0B,iBAA1B;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,eAAP,MAA4B,mBAA5B;;AAEA,IAAIC,UAAU,GAAG,aAAa,YAAY;AACxC;AACA,WAASA,UAAT,CAAoBC,IAApB,EAA0B;AACxBzB,IAAAA,eAAe,CAAC,IAAD,EAAOwB,UAAP,CAAf;;AAEA,SAAKE,KAAL,GAAaD,IAAb;AACA,SAAKE,IAAL,GAAYF,IAAI,CAACE,IAAjB;AACD;;AAEDX,EAAAA,YAAY,CAACQ,UAAD,EAAa,CAAC;AACxBT,IAAAA,GAAG,EAAE,OADmB;AAExBa,IAAAA,KAAK,EAAE,SAASC,KAAT,CAAeC,KAAf,EAAsBC,GAAtB,EAA2B;AAChC;AACA;AACA;AACA,UAAIT,SAAS,EAAb,EAAiB;AACf,eAAOC,eAAe,CAAC,KAAKG,KAAL,CAAWG,KAAX,CAAiBC,KAAjB,EAAwBC,GAAxB,CAAD,CAAtB;AACD;;AAED,UAAIH,KAAK,GAAG,KAAKF,KAAL,CAAWG,KAAX,CAAiBC,KAAjB,EAAwBC,GAAxB,CAAZ;;AAEA,aAAOC,OAAO,CAACC,OAAR,CAAgB;AACrBL,QAAAA,KAAK,EAAEA;AADc,OAAhB,CAAP;AAGD;AAfuB,GAAD,EAgBtB;AACDb,IAAAA,GAAG,EAAE,OADJ;AAEDa,IAAAA,KAAK,EAAE,SAASM,KAAT,GAAiB,CAAC;AACxB;AAHA,GAhBsB,CAAb,CAAZ;;AAsBA,SAAOV,UAAP;AACD,CAhC6B,EAA9B;;AAkCA,IAAIW,YAAY,GAAG,aAAa,YAAY;AAC1C,WAASA,YAAT,CAAsBC,MAAtB,EAA8BC,SAA9B,EAAyC;AACvCrC,IAAAA,eAAe,CAAC,IAAD,EAAOmC,YAAP,CAAf;;AAEA,SAAKG,UAAL,GAAkBD,SAAlB;AACA,SAAKE,OAAL,GAAeC,SAAf;AACA,SAAKC,aAAL,GAAqB,CAArB;AACA,SAAKC,OAAL,GAAeN,MAAf;AACA,SAAKO,KAAL,GAAa,KAAb;AACD;;AAED3B,EAAAA,YAAY,CAACmB,YAAD,EAAe,CAAC;AAC1BpB,IAAAA,GAAG,EAAE,OADqB;AAE1Ba,IAAAA,KAAK,EAAE,SAASC,KAAT,CAAeC,KAAf,EAAsBC,GAAtB,EAA2B;AAChC,UAAID,KAAK,GAAG,KAAKW,aAAjB,EAAgC;AAC9B,eAAOT,OAAO,CAACY,MAAR,CAAe,IAAIC,KAAJ,CAAU,sDAAV,CAAf,CAAP;AACD;;AAED,aAAO,KAAKC,0BAAL,CAAgChB,KAAhC,EAAuCC,GAAvC,CAAP;AACD;AARyB,GAAD,EASxB;AACDhB,IAAAA,GAAG,EAAE,4BADJ;AAEDa,IAAAA,KAAK,EAAE,SAASkB,0BAAT,CAAoChB,KAApC,EAA2CC,GAA3C,EAAgD;AACrD,UAAIgB,KAAK,GAAG,IAAZ;;AAEA,UAAIC,aAAa,GAAGjB,GAAG,IAAI,KAAKU,aAAL,GAAqBQ,GAAG,CAAC,KAAKV,OAAN,CAAnD;;AAEA,UAAI,KAAKI,KAAL,IAAcK,aAAlB,EAAiC;AAC/B,YAAIpB,KAAK,GAAG,KAAKsB,kBAAL,CAAwBpB,KAAxB,EAA+BC,GAA/B,CAAZ;;AAEA,YAAIoB,IAAI,GAAGvB,KAAK,IAAI,IAAT,GAAgB,KAAKe,KAArB,GAA6B,KAAxC;AACA,eAAOX,OAAO,CAACC,OAAR,CAAgB;AACrBL,UAAAA,KAAK,EAAEA,KADc;AAErBuB,UAAAA,IAAI,EAAEA;AAFe,SAAhB,CAAP;AAID;;AAED,aAAO,KAAKT,OAAL,CAAaU,IAAb,GAAoBC,IAApB,CAAyB,UAAUC,IAAV,EAAgB;AAC9C,YAAI1B,KAAK,GAAG0B,IAAI,CAAC1B,KAAjB;AAAA,YACIuB,IAAI,GAAGG,IAAI,CAACH,IADhB;;AAGA,YAAIA,IAAJ,EAAU;AACRJ,UAAAA,KAAK,CAACJ,KAAN,GAAc,IAAd;AACD,SAFD,MAEO,IAAII,KAAK,CAACR,OAAN,KAAkBC,SAAtB,EAAiC;AACtCO,UAAAA,KAAK,CAACR,OAAN,GAAgBX,KAAhB;AACD,SAFM,MAEA;AACLmB,UAAAA,KAAK,CAACR,OAAN,GAAgBgB,MAAM,CAACR,KAAK,CAACR,OAAP,EAAgBX,KAAhB,CAAtB;AACD;;AAED,eAAOmB,KAAK,CAACD,0BAAN,CAAiChB,KAAjC,EAAwCC,GAAxC,CAAP;AACD,OAbM,CAAP;AAcD;AA/BA,GATwB,EAyCxB;AACDhB,IAAAA,GAAG,EAAE,oBADJ;AAEDa,IAAAA,KAAK,EAAE,SAASsB,kBAAT,CAA4BpB,KAA5B,EAAmCC,GAAnC,EAAwC;AAC7C;AACA;AACA;AACA,UAAID,KAAK,GAAG,KAAKW,aAAjB,EAAgC;AAC9B,aAAKF,OAAL,GAAe,KAAKA,OAAL,CAAaV,KAAb,CAAmBC,KAAK,GAAG,KAAKW,aAAhC,CAAf;AACA,aAAKA,aAAL,GAAqBX,KAArB;AACD,OAP4C,CAO3C;;;AAGF,UAAI0B,kBAAkB,GAAGP,GAAG,CAAC,KAAKV,OAAN,CAAH,KAAsB,CAA/C;;AAEA,UAAI,KAAKI,KAAL,IAAca,kBAAlB,EAAsC;AACpC,eAAO,IAAP;AACD,OAd4C,CAc3C;AACF;;;AAGA,aAAO,KAAKjB,OAAL,CAAaV,KAAb,CAAmB,CAAnB,EAAsBE,GAAG,GAAGD,KAA5B,CAAP;AACD;AArBA,GAzCwB,EA+DxB;AACDf,IAAAA,GAAG,EAAE,OADJ;AAEDa,IAAAA,KAAK,EAAE,SAASM,KAAT,GAAiB;AACtB,UAAI,KAAKQ,OAAL,CAAae,MAAjB,EAAyB;AACvB,aAAKf,OAAL,CAAae,MAAb;AACD;AACF;AANA,GA/DwB,CAAf,CAAZ;;AAwEA,SAAOtB,YAAP;AACD,CApF+B,EAAhC;;AAsFA,SAASc,GAAT,CAAaS,WAAb,EAA0B;AACxB,MAAIA,WAAW,KAAKlB,SAApB,EAA+B,OAAO,CAAP;AAC/B,MAAIkB,WAAW,CAAC/B,IAAZ,KAAqBa,SAAzB,EAAoC,OAAOkB,WAAW,CAAC/B,IAAnB;AACpC,SAAO+B,WAAW,CAAClD,MAAnB;AACD;AACD;AACA;AACA;AACA;;;AAGA,SAAS+C,MAAT,CAAgBI,CAAhB,EAAmBC,CAAnB,EAAsB;AACpB,MAAID,CAAC,CAACJ,MAAN,EAAc;AACZ;AACA,WAAOI,CAAC,CAACJ,MAAF,CAASK,CAAT,CAAP;AACD;;AAED,MAAID,CAAC,YAAYE,IAAjB,EAAuB;AACrB,WAAO,IAAIA,IAAJ,CAAS,CAACF,CAAD,EAAIC,CAAJ,CAAT,EAAiB;AACtBE,MAAAA,IAAI,EAAEH,CAAC,CAACG;AADc,KAAjB,CAAP;AAGD;;AAED,MAAIH,CAAC,CAACI,GAAN,EAAW;AACT;AACA,QAAIC,CAAC,GAAG,IAAIL,CAAC,CAACM,WAAN,CAAkBN,CAAC,CAACnD,MAAF,GAAWoD,CAAC,CAACpD,MAA/B,CAAR;AACAwD,IAAAA,CAAC,CAACD,GAAF,CAAMJ,CAAN;AACAK,IAAAA,CAAC,CAACD,GAAF,CAAMH,CAAN,EAASD,CAAC,CAACnD,MAAX;AACA,WAAOwD,CAAP;AACD;;AAED,QAAM,IAAInB,KAAJ,CAAU,mBAAV,CAAN;AACD;;AAED,IAAIqB,UAAU,GAAG,aAAa,YAAY;AACxC,WAASA,UAAT,GAAsB;AACpBlE,IAAAA,eAAe,CAAC,IAAD,EAAOkE,UAAP,CAAf;AACD;;AAEDlD,EAAAA,YAAY,CAACkD,UAAD,EAAa,CAAC;AACxBnD,IAAAA,GAAG,EAAE,UADmB;AAExBa,IAAAA,KAAK,EAAE,SAASuC,QAAT,CAAkBC,KAAlB,EAAyB/B,SAAzB,EAAoC;AACzC;AACA;AACA;AACA;AACA,UAAIjB,aAAa,MAAMgD,KAAnB,IAA4B,OAAOA,KAAK,CAACC,GAAb,KAAqB,WAArD,EAAkE;AAChE,eAAOhD,SAAS,CAAC+C,KAAK,CAACC,GAAP,CAAT,CAAqBhB,IAArB,CAA0B,UAAUiB,IAAV,EAAgB;AAC/C,iBAAO,IAAI9C,UAAJ,CAAe8C,IAAf,CAAP;AACD,SAFM,EAEJ,OAFI,EAEK,UAAUC,GAAV,EAAe;AACzB,gBAAM,IAAI1B,KAAJ,CAAU,sFAAsFU,MAAtF,CAA6FgB,GAA7F,CAAV,CAAN;AACD,SAJM,CAAP;AAKD,OAXwC,CAWvC;AACF;AACA;AACA;;;AAGA,UAAI,OAAOH,KAAK,CAACvC,KAAb,KAAuB,UAAvB,IAAqC,OAAOuC,KAAK,CAACzC,IAAb,KAAsB,WAA/D,EAA4E;AAC1E,eAAOK,OAAO,CAACC,OAAR,CAAgB,IAAIT,UAAJ,CAAe4C,KAAf,CAAhB,CAAP;AACD;;AAED,UAAI,OAAOA,KAAK,CAAChB,IAAb,KAAsB,UAA1B,EAAsC;AACpCf,QAAAA,SAAS,GAAG,CAACA,SAAb;;AAEA,YAAI,CAACmC,QAAQ,CAACnC,SAAD,CAAb,EAA0B;AACxB,iBAAOL,OAAO,CAACY,MAAR,CAAe,IAAIC,KAAJ,CAAU,mFAAV,CAAf,CAAP;AACD;;AAED,eAAOb,OAAO,CAACC,OAAR,CAAgB,IAAIE,YAAJ,CAAiBiC,KAAjB,EAAwB/B,SAAxB,CAAhB,CAAP;AACD;;AAED,aAAOL,OAAO,CAACY,MAAR,CAAe,IAAIC,KAAJ,CAAU,oFAAV,CAAf,CAAP;AACD;AAlCuB,GAAD,CAAb,CAAZ;;AAqCA,SAAOqB,UAAP;AACD,CA3C6B,EAA9B;;AA6CA,SAASA,UAAU,IAAIO,OAAvB","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport isReactNative from './isReactNative';\nimport uriToBlob from './uriToBlob';\nimport isCordova from './isCordova';\nimport readAsByteArray from './readAsByteArray';\n\nvar FileSource = /*#__PURE__*/function () {\n  // Make this.size a method\n  function FileSource(file) {\n    _classCallCheck(this, FileSource);\n\n    this._file = file;\n    this.size = file.size;\n  }\n\n  _createClass(FileSource, [{\n    key: \"slice\",\n    value: function slice(start, end) {\n      // In Apache Cordova applications, a File must be resolved using\n      // FileReader instances, see\n      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file\n      if (isCordova()) {\n        return readAsByteArray(this._file.slice(start, end));\n      }\n\n      var value = this._file.slice(start, end);\n\n      return Promise.resolve({\n        value: value\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close() {// Nothing to do here since we don't need to release any resources.\n    }\n  }]);\n\n  return FileSource;\n}();\n\nvar StreamSource = /*#__PURE__*/function () {\n  function StreamSource(reader, chunkSize) {\n    _classCallCheck(this, StreamSource);\n\n    this._chunkSize = chunkSize;\n    this._buffer = undefined;\n    this._bufferOffset = 0;\n    this._reader = reader;\n    this._done = false;\n  }\n\n  _createClass(StreamSource, [{\n    key: \"slice\",\n    value: function slice(start, end) {\n      if (start < this._bufferOffset) {\n        return Promise.reject(new Error(\"Requested data is before the reader's current offset\"));\n      }\n\n      return this._readUntilEnoughDataOrDone(start, end);\n    }\n  }, {\n    key: \"_readUntilEnoughDataOrDone\",\n    value: function _readUntilEnoughDataOrDone(start, end) {\n      var _this = this;\n\n      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);\n\n      if (this._done || hasEnoughData) {\n        var value = this._getDataFromBuffer(start, end);\n\n        var done = value == null ? this._done : false;\n        return Promise.resolve({\n          value: value,\n          done: done\n        });\n      }\n\n      return this._reader.read().then(function (_ref) {\n        var value = _ref.value,\n            done = _ref.done;\n\n        if (done) {\n          _this._done = true;\n        } else if (_this._buffer === undefined) {\n          _this._buffer = value;\n        } else {\n          _this._buffer = concat(_this._buffer, value);\n        }\n\n        return _this._readUntilEnoughDataOrDone(start, end);\n      });\n    }\n  }, {\n    key: \"_getDataFromBuffer\",\n    value: function _getDataFromBuffer(start, end) {\n      // Remove data from buffer before `start`.\n      // Data might be reread from the buffer if an upload fails, so we can only\n      // safely delete data when it comes *before* what is currently being read.\n      if (start > this._bufferOffset) {\n        this._buffer = this._buffer.slice(start - this._bufferOffset);\n        this._bufferOffset = start;\n      } // If the buffer is empty after removing old data, all data has been read.\n\n\n      var hasAllDataBeenRead = len(this._buffer) === 0;\n\n      if (this._done && hasAllDataBeenRead) {\n        return null;\n      } // We already removed data before `start`, so we just return the first\n      // chunk from the buffer.\n\n\n      return this._buffer.slice(0, end - start);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._reader.cancel) {\n        this._reader.cancel();\n      }\n    }\n  }]);\n\n  return StreamSource;\n}();\n\nfunction len(blobOrArray) {\n  if (blobOrArray === undefined) return 0;\n  if (blobOrArray.size !== undefined) return blobOrArray.size;\n  return blobOrArray.length;\n}\n/*\n  Typed arrays and blobs don't have a concat method.\n  This function helps StreamSource accumulate data to reach chunkSize.\n*/\n\n\nfunction concat(a, b) {\n  if (a.concat) {\n    // Is `a` an Array?\n    return a.concat(b);\n  }\n\n  if (a instanceof Blob) {\n    return new Blob([a, b], {\n      type: a.type\n    });\n  }\n\n  if (a.set) {\n    // Is `a` a typed array?\n    var c = new a.constructor(a.length + b.length);\n    c.set(a);\n    c.set(b, a.length);\n    return c;\n  }\n\n  throw new Error('Unknown data type');\n}\n\nvar FileReader = /*#__PURE__*/function () {\n  function FileReader() {\n    _classCallCheck(this, FileReader);\n  }\n\n  _createClass(FileReader, [{\n    key: \"openFile\",\n    value: function openFile(input, chunkSize) {\n      // In React Native, when user selects a file, instead of a File or Blob,\n      // you usually get a file object {} with a uri property that contains\n      // a local path to the file. We use XMLHttpRequest to fetch\n      // the file blob, before uploading with tus.\n      if (isReactNative() && input && typeof input.uri !== 'undefined') {\n        return uriToBlob(input.uri).then(function (blob) {\n          return new FileSource(blob);\n        })[\"catch\"](function (err) {\n          throw new Error(\"tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. \".concat(err));\n        });\n      } // Since we emulate the Blob type in our tests (not all target browsers\n      // support it), we cannot use `instanceof` for testing whether the input value\n      // can be handled. Instead, we simply check is the slice() function and the\n      // size property are available.\n\n\n      if (typeof input.slice === 'function' && typeof input.size !== 'undefined') {\n        return Promise.resolve(new FileSource(input));\n      }\n\n      if (typeof input.read === 'function') {\n        chunkSize = +chunkSize;\n\n        if (!isFinite(chunkSize)) {\n          return Promise.reject(new Error('cannot create source for stream without a finite value for the `chunkSize` option'));\n        }\n\n        return Promise.resolve(new StreamSource(input, chunkSize));\n      }\n\n      return Promise.reject(new Error('source object may only be an instance of File, Blob, or Reader in this environment'));\n    }\n  }]);\n\n  return FileReader;\n}();\n\nexport { FileReader as default };"]},"metadata":{},"sourceType":"module"}