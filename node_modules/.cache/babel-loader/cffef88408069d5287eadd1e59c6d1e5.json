{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/* global window */\n\n\nimport { Base64 } from 'js-base64';\nimport URL from 'url-parse';\nimport DetailedError from './error';\nimport { log } from './logger';\nimport uuid from './uuid';\nvar defaultOptions = {\n  endpoint: null,\n  uploadUrl: null,\n  metadata: {},\n  fingerprint: null,\n  uploadSize: null,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  _onUploadUrlAvailable: null,\n  overridePatchMethod: false,\n  headers: {},\n  addRequestId: false,\n  onBeforeRequest: null,\n  onAfterResponse: null,\n  onShouldRetry: null,\n  chunkSize: Infinity,\n  retryDelays: [0, 1000, 3000, 5000],\n  parallelUploads: 1,\n  storeFingerprintForResuming: true,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  uploadDataDuringCreation: false,\n  urlStorage: null,\n  fileReader: null,\n  httpStack: null\n};\n\nvar BaseUpload = /*#__PURE__*/function () {\n  function BaseUpload(file, options) {\n    _classCallCheck(this, BaseUpload); // Warn about removed options from previous versions\n\n\n    if ('resume' in options) {\n      console.log('tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.'); // eslint-disable-line no-console\n    } // The default options will already be added from the wrapper classes.\n\n\n    this.options = options; // The storage module used to store URLs\n\n    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object\n\n    this.file = file; // The URL against which the file will be uploaded\n\n    this.url = null; // The underlying request object for the current PATCH request\n\n    this._req = null; // The fingerpinrt for the current file (set after start())\n\n    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,\n\n    this._urlStorageKey = null; // The offset used in the current PATCH request\n\n    this._offset = null; // True if the current PATCH request has been aborted\n\n    this._aborted = false; // The file's size in bytes\n\n    this._size = null; // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n\n    this._source = null; // The current count of attempts which have been made. Zero indicates none.\n\n    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry\n\n    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.\n\n    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different\n    // parts, if the parallelUploads option is used.\n\n    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different\n    // parts, if the parallelUploads option is used.\n\n    this._parallelUploadUrls = null;\n  }\n  /**\n   * Use the Termination extension to delete an upload from the server by sending a DELETE\n   * request to the specified upload URL. This is only possible if the server supports the\n   * Termination extension. If the `options.retryDelays` property is set, the method will\n   * also retry if an error ocurrs.\n   *\n   * @param {String} url The upload's URL which will be terminated.\n   * @param {object} options Optional options for influencing HTTP requests.\n   * @return {Promise} The Promise will be resolved/rejected when the requests finish.\n   */\n\n\n  _createClass(BaseUpload, [{\n    key: \"findPreviousUploads\",\n    value: function findPreviousUploads() {\n      var _this = this;\n\n      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {\n        return _this._urlStorage.findUploadsByFingerprint(fingerprint);\n      });\n    }\n  }, {\n    key: \"resumeFromPreviousUpload\",\n    value: function resumeFromPreviousUpload(previousUpload) {\n      this.url = previousUpload.uploadUrl || null;\n      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;\n      this._urlStorageKey = previousUpload.urlStorageKey;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n\n      var file = this.file;\n\n      if (!file) {\n        this._emitError(new Error('tus: no file or stream to upload provided'));\n\n        return;\n      }\n\n      if (!this.options.endpoint && !this.options.uploadUrl) {\n        this._emitError(new Error('tus: neither an endpoint or an upload URL is provided'));\n\n        return;\n      }\n\n      var retryDelays = this.options.retryDelays;\n\n      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== '[object Array]') {\n        this._emitError(new Error('tus: the `retryDelays` option must either be an array or null'));\n\n        return;\n      }\n\n      if (this.options.parallelUploads > 1) {\n        // Test which options are incompatible with parallel uploads.\n        ['uploadUrl', 'uploadSize', 'uploadLengthDeferred'].forEach(function (optionName) {\n          if (_this2.options[optionName]) {\n            _this2._emitError(new Error(\"tus: cannot use the \".concat(optionName, \" option when parallelUploads is enabled\")));\n          }\n        });\n      }\n\n      this.options.fingerprint(file, this.options).then(function (fingerprint) {\n        if (fingerprint == null) {\n          log('No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.');\n        } else {\n          log(\"Calculated fingerprint: \".concat(fingerprint));\n        }\n\n        _this2._fingerprint = fingerprint;\n\n        if (_this2._source) {\n          return _this2._source;\n        }\n\n        return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);\n      }).then(function (source) {\n        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from\n        // an upload which used multiple requests, we start a parallel upload.\n\n        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {\n          _this2._startParallelUpload();\n        } else {\n          _this2._startSingleUpload();\n        }\n      })[\"catch\"](function (err) {\n        _this2._emitError(err);\n      });\n    }\n    /**\n     * Initiate the uploading procedure for a parallelized upload, where one file is split into\n     * multiple request which are run in parallel.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_startParallelUpload\",\n    value: function _startParallelUpload() {\n      var _this3 = this;\n\n      var totalSize = this._size = this._source.size;\n      var totalProgress = 0;\n      this._parallelUploads = [];\n      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate\n      // requests. Here we generate the start and end position for the slices.\n\n      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs\n\n      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective\n      // upload is completed.\n\n      var uploads = parts.map(function (part, index) {\n        var lastPartProgress = 0;\n        return _this3._source.slice(part.start, part.end).then(function (_ref) {\n          var value = _ref.value;\n          return new Promise(function (resolve, reject) {\n            // Merge with the user supplied options but overwrite some values.\n            var options = _objectSpread({}, _this3.options, {\n              // If available, the partial upload should be resumed from a previous URL.\n              uploadUrl: part.uploadUrl || null,\n              // We take manually care of resuming for partial uploads, so they should\n              // not be stored in the URL storage.\n              storeFingerprintForResuming: false,\n              removeFingerprintOnSuccess: false,\n              // Reset the parallelUploads option to not cause recursion.\n              parallelUploads: 1,\n              metadata: {},\n              // Add the header to indicate the this is a partial upload.\n              headers: _objectSpread({}, _this3.options.headers, {\n                'Upload-Concat': 'partial'\n              }),\n              // Reject or resolve the promise if the upload errors or completes.\n              onSuccess: resolve,\n              onError: reject,\n              // Based in the progress for this partial upload, calculate the progress\n              // for the entire final upload.\n              onProgress: function onProgress(newPartProgress) {\n                totalProgress = totalProgress - lastPartProgress + newPartProgress;\n                lastPartProgress = newPartProgress;\n\n                _this3._emitProgress(totalProgress, totalSize);\n              },\n              // Wait until every partial upload has an upload URL, so we can add\n              // them to the URL storage.\n              _onUploadUrlAvailable: function _onUploadUrlAvailable() {\n                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL\n\n                if (_this3._parallelUploadUrls.filter(function (u) {\n                  return !!u;\n                }).length === parts.length) {\n                  _this3._saveUploadInUrlStorage();\n                }\n              }\n            });\n\n            var upload = new BaseUpload(value, options);\n            upload.start(); // Store the upload in an array, so we can later abort them if necessary.\n\n            _this3._parallelUploads.push(upload);\n          });\n        });\n      });\n      var req; // Wait until all partial uploads are finished and we can send the POST request for\n      // creating the final upload.\n\n      Promise.all(uploads).then(function () {\n        req = _this3._openRequest('POST', _this3.options.endpoint);\n        req.setHeader('Upload-Concat', \"final;\".concat(_this3._parallelUploadUrls.join(' '))); // Add metadata if values have been added\n\n        var metadata = encodeMetadata(_this3.options.metadata);\n\n        if (metadata !== '') {\n          req.setHeader('Upload-Metadata', metadata);\n        }\n\n        return _this3._sendRequest(req, null);\n      }).then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this3._emitHttpError(req, res, 'tus: unexpected response while creating upload');\n\n          return;\n        }\n\n        var location = res.getHeader('Location');\n\n        if (location == null) {\n          _this3._emitHttpError(req, res, 'tus: invalid or missing Location header');\n\n          return;\n        }\n\n        _this3.url = resolveUrl(_this3.options.endpoint, location);\n        log(\"Created upload at \".concat(_this3.url));\n\n        _this3._emitSuccess();\n      })[\"catch\"](function (err) {\n        _this3._emitError(err);\n      });\n    }\n    /**\n     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is\n     * uploaded in a sequential matter.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_startSingleUpload\",\n    value: function _startSingleUpload() {\n      // First, we look at the uploadLengthDeferred option.\n      // Next, we check if the caller has supplied a manual upload size.\n      // Finally, we try to use the calculated size from the source object.\n      if (this.options.uploadLengthDeferred) {\n        this._size = null;\n      } else if (this.options.uploadSize != null) {\n        this._size = +this.options.uploadSize;\n\n        if (isNaN(this._size)) {\n          this._emitError(new Error('tus: cannot convert `uploadSize` option into a number'));\n\n          return;\n        }\n      } else {\n        this._size = this._source.size;\n\n        if (this._size == null) {\n          this._emitError(new Error(\"tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option\"));\n\n          return;\n        }\n      } // Reset the aborted flag when the upload is started or else the\n      // _performUpload will stop before sending a request if the upload has been\n      // aborted previously.\n\n\n      this._aborted = false; // The upload had been started previously and we should reuse this URL.\n\n      if (this.url != null) {\n        log(\"Resuming upload from previous URL: \".concat(this.url));\n\n        this._resumeUpload();\n\n        return;\n      } // A URL has manually been specified, so we try to resume\n\n\n      if (this.options.uploadUrl != null) {\n        log(\"Resuming upload from provided URL: \".concat(this.options.url));\n        this.url = this.options.uploadUrl;\n\n        this._resumeUpload();\n\n        return;\n      } // An upload has not started for the file yet, so we start a new one\n\n\n      log('Creating a new upload');\n\n      this._createUpload();\n    }\n    /**\n     * Abort any running request and stop the current upload. After abort is called, no event\n     * handler will be invoked anymore. You can use the `start` method to resume the upload\n     * again.\n     * If `shouldTerminate` is true, the `terminate` function will be called to remove the\n     * current upload from the server.\n     *\n     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.\n     * @return {Promise} The Promise will be resolved/rejected when the requests finish.\n     */\n\n  }, {\n    key: \"abort\",\n    value: function abort(shouldTerminate) {\n      var _this4 = this; // Count the number of arguments to see if a callback is being provided in the old style required by tus-js-client 1.x, then throw an error if it is.\n      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.\n\n\n      if (arguments.length > 1 && typeof arguments[1] === 'function') {\n        throw new Error('tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead');\n      } // Stop any parallel partial uploads, that have been started in _startParallelUploads.\n\n\n      if (this._parallelUploads != null) {\n        this._parallelUploads.forEach(function (upload) {\n          upload.abort(shouldTerminate);\n        });\n      } // Stop any current running request.\n\n\n      if (this._req !== null) {\n        this._req.abort();\n\n        this._source.close();\n      }\n\n      this._aborted = true; // Stop any timeout used for initiating a retry.\n\n      if (this._retryTimeout != null) {\n        clearTimeout(this._retryTimeout);\n        this._retryTimeout = null;\n      }\n\n      if (!shouldTerminate || this.url == null) {\n        return Promise.resolve();\n      }\n\n      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.\n      .then(function () {\n        return _this4._removeFromUrlStorage();\n      });\n    }\n  }, {\n    key: \"_emitHttpError\",\n    value: function _emitHttpError(req, res, message, causingErr) {\n      this._emitError(new DetailedError(message, causingErr, req, res));\n    }\n  }, {\n    key: \"_emitError\",\n    value: function _emitError(err) {\n      var _this5 = this; // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.\n\n\n      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.\n\n      if (this.options.retryDelays != null) {\n        // We will reset the attempt counter if\n        // - we were already able to connect to the server (offset != null) and\n        // - we were able to upload a small chunk of data to the server\n        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;\n\n        if (shouldResetDelays) {\n          this._retryAttempt = 0;\n        }\n\n        if (shouldRetry(err, this._retryAttempt, this.options)) {\n          var delay = this.options.retryDelays[this._retryAttempt++];\n          this._offsetBeforeRetry = this._offset;\n          this._retryTimeout = setTimeout(function () {\n            _this5.start();\n          }, delay);\n          return;\n        }\n      }\n\n      if (typeof this.options.onError === 'function') {\n        this.options.onError(err);\n      } else {\n        throw err;\n      }\n    }\n    /**\n     * Publishes notification if the upload has been successfully completed.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_emitSuccess\",\n    value: function _emitSuccess() {\n      if (this.options.removeFingerprintOnSuccess) {\n        // Remove stored fingerprint and corresponding endpoint. This causes\n        // new uploads of the same file to be treated as a different file.\n        this._removeFromUrlStorage();\n      }\n\n      if (typeof this.options.onSuccess === 'function') {\n        this.options.onSuccess();\n      }\n    }\n    /**\n     * Publishes notification when data has been sent to the server. This\n     * data may not have been accepted by the server yet.\n     *\n     * @param {number} bytesSent  Number of bytes sent to the server.\n     * @param {number} bytesTotal Total number of bytes to be sent to the server.\n     * @api private\n     */\n\n  }, {\n    key: \"_emitProgress\",\n    value: function _emitProgress(bytesSent, bytesTotal) {\n      if (typeof this.options.onProgress === 'function') {\n        this.options.onProgress(bytesSent, bytesTotal);\n      }\n    }\n    /**\n     * Publishes notification when a chunk of data has been sent to the server\n     * and accepted by the server.\n     * @param {number} chunkSize  Size of the chunk that was accepted by the server.\n     * @param {number} bytesAccepted Total number of bytes that have been\n     *                                accepted by the server.\n     * @param {number} bytesTotal Total number of bytes to be sent to the server.\n     * @api private\n     */\n\n  }, {\n    key: \"_emitChunkComplete\",\n    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n      if (typeof this.options.onChunkComplete === 'function') {\n        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n      }\n    }\n    /**\n     * Create a new upload using the creation extension by sending a POST\n     * request to the endpoint. After successful creation the file will be\n     * uploaded\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_createUpload\",\n    value: function _createUpload() {\n      var _this6 = this;\n\n      if (!this.options.endpoint) {\n        this._emitError(new Error('tus: unable to create upload because no endpoint is provided'));\n\n        return;\n      }\n\n      var req = this._openRequest('POST', this.options.endpoint);\n\n      if (this.options.uploadLengthDeferred) {\n        req.setHeader('Upload-Defer-Length', 1);\n      } else {\n        req.setHeader('Upload-Length', this._size);\n      } // Add metadata if values have been added\n\n\n      var metadata = encodeMetadata(this.options.metadata);\n\n      if (metadata !== '') {\n        req.setHeader('Upload-Metadata', metadata);\n      }\n\n      var promise;\n\n      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {\n        this._offset = 0;\n        promise = this._addChunkToRequest(req);\n      } else {\n        promise = this._sendRequest(req, null);\n      }\n\n      promise.then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this6._emitHttpError(req, res, 'tus: unexpected response while creating upload');\n\n          return;\n        }\n\n        var location = res.getHeader('Location');\n\n        if (location == null) {\n          _this6._emitHttpError(req, res, 'tus: invalid or missing Location header');\n\n          return;\n        }\n\n        _this6.url = resolveUrl(_this6.options.endpoint, location);\n        log(\"Created upload at \".concat(_this6.url));\n\n        if (typeof _this6.options._onUploadUrlAvailable === 'function') {\n          _this6.options._onUploadUrlAvailable();\n        }\n\n        if (_this6._size === 0) {\n          // Nothing to upload and file was successfully created\n          _this6._emitSuccess();\n\n          _this6._source.close();\n\n          return;\n        }\n\n        _this6._saveUploadInUrlStorage();\n\n        if (_this6.options.uploadDataDuringCreation) {\n          _this6._handleUploadResponse(req, res);\n        } else {\n          _this6._offset = 0;\n\n          _this6._performUpload();\n        }\n      })[\"catch\"](function (err) {\n        _this6._emitHttpError(req, null, 'tus: failed to create upload', err);\n      });\n    }\n    /*\n     * Try to resume an existing upload. First a HEAD request will be sent\n     * to retrieve the offset. If the request fails a new upload will be\n     * created. In the case of a successful response the file will be uploaded.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_resumeUpload\",\n    value: function _resumeUpload() {\n      var _this7 = this;\n\n      var req = this._openRequest('HEAD', this.url);\n\n      var promise = this._sendRequest(req, null);\n\n      promise.then(function (res) {\n        var status = res.getStatus();\n\n        if (!inStatusCategory(status, 200)) {\n          if (inStatusCategory(status, 400)) {\n            // Remove stored fingerprint and corresponding endpoint,\n            // on client errors since the file can not be found\n            _this7._removeFromUrlStorage();\n          } // If the upload is locked (indicated by the 423 Locked status code), we\n          // emit an error instead of directly starting a new upload. This way the\n          // retry logic can catch the error and will retry the upload. An upload\n          // is usually locked for a short period of time and will be available\n          // afterwards.\n\n\n          if (status === 423) {\n            _this7._emitHttpError(req, res, 'tus: upload is currently locked; retry later');\n\n            return;\n          }\n\n          if (!_this7.options.endpoint) {\n            // Don't attempt to create a new upload if no endpoint is provided.\n            _this7._emitHttpError(req, res, 'tus: unable to resume upload (new upload cannot be created without an endpoint)');\n\n            return;\n          } // Try to create a new upload\n\n\n          _this7.url = null;\n\n          _this7._createUpload();\n\n          return;\n        }\n\n        var offset = parseInt(res.getHeader('Upload-Offset'), 10);\n\n        if (isNaN(offset)) {\n          _this7._emitHttpError(req, res, 'tus: invalid or missing offset value');\n\n          return;\n        }\n\n        var length = parseInt(res.getHeader('Upload-Length'), 10);\n\n        if (isNaN(length) && !_this7.options.uploadLengthDeferred) {\n          _this7._emitHttpError(req, res, 'tus: invalid or missing length value');\n\n          return;\n        }\n\n        if (typeof _this7.options._onUploadUrlAvailable === 'function') {\n          _this7.options._onUploadUrlAvailable();\n        } // Upload has already been completed and we do not need to send additional\n        // data to the server\n\n\n        if (offset === length) {\n          _this7._emitProgress(length, length);\n\n          _this7._emitSuccess();\n\n          return;\n        }\n\n        _this7._offset = offset;\n\n        _this7._performUpload();\n      })[\"catch\"](function (err) {\n        _this7._emitHttpError(req, null, 'tus: failed to resume upload', err);\n      });\n    }\n    /**\n     * Start uploading the file using PATCH requests. The file will be divided\n     * into chunks as specified in the chunkSize option. During the upload\n     * the onProgress event handler may be invoked multiple times.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_performUpload\",\n    value: function _performUpload() {\n      var _this8 = this; // If the upload has been aborted, we will not send the next PATCH request.\n      // This is important if the abort method was called during a callback, such\n      // as onChunkComplete or onProgress.\n\n\n      if (this._aborted) {\n        return;\n      }\n\n      var req; // Some browser and servers may not support the PATCH method. For those\n      // cases, you can tell tus-js-client to use a POST request with the\n      // X-HTTP-Method-Override header for simulating a PATCH request.\n\n      if (this.options.overridePatchMethod) {\n        req = this._openRequest('POST', this.url);\n        req.setHeader('X-HTTP-Method-Override', 'PATCH');\n      } else {\n        req = this._openRequest('PATCH', this.url);\n      }\n\n      req.setHeader('Upload-Offset', this._offset);\n\n      var promise = this._addChunkToRequest(req);\n\n      promise.then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this8._emitHttpError(req, res, 'tus: unexpected response while uploading chunk');\n\n          return;\n        }\n\n        _this8._handleUploadResponse(req, res);\n      })[\"catch\"](function (err) {\n        // Don't emit an error if the upload was aborted manually\n        if (_this8._aborted) {\n          return;\n        }\n\n        _this8._emitHttpError(req, null, \"tus: failed to upload chunk at offset \".concat(_this8._offset), err);\n      });\n    }\n    /**\n     * _addChunktoRequest reads a chunk from the source and sends it using the\n     * supplied request object. It will not handle the response.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_addChunkToRequest\",\n    value: function _addChunkToRequest(req) {\n      var _this9 = this;\n\n      var start = this._offset;\n      var end = this._offset + this.options.chunkSize;\n      req.setProgressHandler(function (bytesSent) {\n        _this9._emitProgress(start + bytesSent, _this9._size);\n      });\n      req.setHeader('Content-Type', 'application/offset+octet-stream'); // The specified chunkSize may be Infinity or the calcluated end position\n      // may exceed the file's size. In both cases, we limit the end position to\n      // the input's total size for simpler calculations and correctness.\n\n      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {\n        end = this._size;\n      }\n\n      return this._source.slice(start, end).then(function (_ref2) {\n        var value = _ref2.value,\n            done = _ref2.done; // If the upload length is deferred, the upload size was not specified during\n        // upload creation. So, if the file reader is done reading, we know the total\n        // upload size and can tell the tus server.\n\n        if (_this9.options.uploadLengthDeferred && done) {\n          _this9._size = _this9._offset + (value && value.size ? value.size : 0);\n          req.setHeader('Upload-Length', _this9._size);\n        }\n\n        if (value === null) {\n          return _this9._sendRequest(req);\n        }\n\n        _this9._emitProgress(_this9._offset, _this9._size);\n\n        return _this9._sendRequest(req, value);\n      });\n    }\n    /**\n     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest\n     * and already have received a response.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_handleUploadResponse\",\n    value: function _handleUploadResponse(req, res) {\n      var offset = parseInt(res.getHeader('Upload-Offset'), 10);\n\n      if (isNaN(offset)) {\n        this._emitHttpError(req, res, 'tus: invalid or missing offset value');\n\n        return;\n      }\n\n      this._emitProgress(offset, this._size);\n\n      this._emitChunkComplete(offset - this._offset, offset, this._size);\n\n      this._offset = offset;\n\n      if (offset == this._size) {\n        // Yay, finally done :)\n        this._emitSuccess();\n\n        this._source.close();\n\n        return;\n      }\n\n      this._performUpload();\n    }\n    /**\n     * Create a new HTTP request object with the given method and URL.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_openRequest\",\n    value: function _openRequest(method, url) {\n      var req = openRequest(method, url, this.options);\n      this._req = req;\n      return req;\n    }\n    /**\n     * Remove the entry in the URL storage, if it has been saved before.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_removeFromUrlStorage\",\n    value: function _removeFromUrlStorage() {\n      var _this10 = this;\n\n      if (!this._urlStorageKey) return;\n\n      this._urlStorage.removeUpload(this._urlStorageKey)[\"catch\"](function (err) {\n        _this10._emitError(err);\n      });\n\n      this._urlStorageKey = null;\n    }\n    /**\n     * Add the upload URL to the URL storage, if possible.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_saveUploadInUrlStorage\",\n    value: function _saveUploadInUrlStorage() {\n      var _this11 = this; // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.\n\n\n      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {\n        return;\n      }\n\n      var storedUpload = {\n        size: this._size,\n        metadata: this.options.metadata,\n        creationTime: new Date().toString()\n      };\n\n      if (this._parallelUploads) {\n        // Save multiple URLs if the parallelUploads option is used ...\n        storedUpload.parallelUploadUrls = this._parallelUploadUrls;\n      } else {\n        // ... otherwise we just save the one available URL.\n        storedUpload.uploadUrl = this.url;\n      }\n\n      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {\n        return _this11._urlStorageKey = urlStorageKey;\n      })[\"catch\"](function (err) {\n        _this11._emitError(err);\n      });\n    }\n    /**\n     * Send a request with the provided body.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_sendRequest\",\n    value: function _sendRequest(req) {\n      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return sendRequest(req, body, this.options);\n    }\n  }], [{\n    key: \"terminate\",\n    value: function terminate(url, options) {\n      // Count the number of arguments to see if a callback is being provided as the last\n      // argument in the old style required by tus-js-client 1.x, then throw an error if it is.\n      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.\n      if (arguments.length > 1 && typeof arguments[arguments.length - 1] === 'function') {\n        throw new Error('tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead');\n      } // Note that in order for the trick above to work, a default value cannot be set for `options`,\n      // so the check below replaces the old default `{}`.\n\n\n      if (options === undefined) {\n        options = {};\n      }\n\n      var req = openRequest('DELETE', url, options);\n      return sendRequest(req, null, options).then(function (res) {\n        // A 204 response indicates a successfull request\n        if (res.getStatus() === 204) {\n          return;\n        }\n\n        throw new DetailedError('tus: unexpected response while terminating upload', null, req, res);\n      })[\"catch\"](function (err) {\n        if (!(err instanceof DetailedError)) {\n          err = new DetailedError('tus: failed to terminate upload', err, req, null);\n        }\n\n        if (!shouldRetry(err, 0, options)) {\n          throw err;\n        } // Instead of keeping track of the retry attempts, we remove the first element from the delays\n        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.\n        // We recursively call the terminate function will removing elements from the retryDelays array.\n\n\n        var delay = options.retryDelays[0];\n        var remainingDelays = options.retryDelays.slice(1);\n\n        var newOptions = _objectSpread({}, options, {\n          retryDelays: remainingDelays\n        });\n\n        return new Promise(function (resolve) {\n          return setTimeout(resolve, delay);\n        }).then(function () {\n          return BaseUpload.terminate(url, newOptions);\n        });\n      });\n    }\n  }]);\n\n  return BaseUpload;\n}();\n\nfunction encodeMetadata(metadata) {\n  var encoded = [];\n\n  for (var key in metadata) {\n    encoded.push(\"\".concat(key, \" \").concat(Base64.encode(metadata[key])));\n  }\n\n  return encoded.join(',');\n}\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\n\n\nfunction inStatusCategory(status, category) {\n  return status >= category && status < category + 100;\n}\n/**\n * Create a new HTTP request with the specified method and URL.\n * The necessary headers that are included in every request\n * will be added, including the request ID.\n *\n * @api private\n */\n\n\nfunction openRequest(method, url, options) {\n  var req = options.httpStack.createRequest(method, url);\n  req.setHeader('Tus-Resumable', '1.0.0');\n  var headers = options.headers || {};\n\n  for (var name in headers) {\n    req.setHeader(name, headers[name]);\n  }\n\n  if (options.addRequestId) {\n    var requestId = uuid();\n    req.setHeader('X-Request-ID', requestId);\n  }\n\n  return req;\n}\n/**\n * Send a request with the provided body while invoking the onBeforeRequest\n * and onAfterResponse callbacks.\n *\n * @api private\n */\n\n\nfunction sendRequest(req, body, options) {\n  var onBeforeRequestPromise = typeof options.onBeforeRequest === 'function' ? Promise.resolve(options.onBeforeRequest(req)) : Promise.resolve();\n  return onBeforeRequestPromise.then(function () {\n    return req.send(body).then(function (res) {\n      var onAfterResponsePromise = typeof options.onAfterResponse === 'function' ? Promise.resolve(options.onAfterResponse(req, res)) : Promise.resolve();\n      return onAfterResponsePromise.then(function () {\n        return res;\n      });\n    });\n  });\n}\n/**\n * Checks whether the browser running this code has internet access.\n * This function will always return true in the node.js environment\n *\n * @api private\n */\n\n\nfunction isOnline() {\n  var online = true;\n\n  if (typeof window !== 'undefined' && 'navigator' in window && window.navigator.onLine === false) {\n    online = false;\n  }\n\n  return online;\n}\n/**\n * Checks whether or not it is ok to retry a request.\n * @param {Error} err the error returned from the last request\n * @param {number} retryAttempt the number of times the request has already been retried\n * @param {object} options tus Upload options\n *\n * @api private\n */\n\n\nfunction shouldRetry(err, retryAttempt, options) {\n  // We only attempt a retry if\n  // - retryDelays option is set\n  // - we didn't exceed the maxium number of retries, yet, and\n  // - this error was caused by a request or it's response and\n  // - the error is server error (i.e. not a status 4xx except a 409 or 423) or\n  // a onShouldRetry is specified and returns true\n  // - the browser does not indicate that we are offline\n  if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {\n    return false;\n  }\n\n  if (options && typeof options.onShouldRetry === 'function') {\n    return options.onShouldRetry(err, retryAttempt, options);\n  }\n\n  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;\n  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline();\n}\n/**\n * Resolve a relative link given the origin as source. For example,\n * if a HTTP request to http://example.com/files/ returns a Location\n * header with the value /upload/abc, the resolved URL will be:\n * http://example.com/upload/abc\n */\n\n\nfunction resolveUrl(origin, link) {\n  return new URL(link, origin).toString();\n}\n/**\n * Calculate the start and end positions for the parts if an upload\n * is split into multiple parallel requests.\n *\n * @param {number} totalSize The byte size of the upload, which will be split.\n * @param {number} partCount The number in how many parts the upload will be split.\n * @param {string[]} previousUrls The upload URLs for previous parts.\n * @return {object[]}\n * @api private\n */\n\n\nfunction splitSizeIntoParts(totalSize, partCount, previousUrls) {\n  var partSize = Math.floor(totalSize / partCount);\n  var parts = [];\n\n  for (var i = 0; i < partCount; i++) {\n    parts.push({\n      start: partSize * i,\n      end: partSize * (i + 1)\n    });\n  }\n\n  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.\n\n  if (previousUrls) {\n    parts.forEach(function (part, index) {\n      part.uploadUrl = previousUrls[index] || null;\n    });\n  }\n\n  return parts;\n}\n\nBaseUpload.defaultOptions = defaultOptions;\nexport default BaseUpload;","map":{"version":3,"sources":["/home/joao/Projects/iconect_test/dropzone/node_modules/tus-js-client/lib.esm/upload.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","prototype","Base64","URL","DetailedError","log","uuid","defaultOptions","endpoint","uploadUrl","metadata","fingerprint","uploadSize","onProgress","onChunkComplete","onSuccess","onError","_onUploadUrlAvailable","overridePatchMethod","headers","addRequestId","onBeforeRequest","onAfterResponse","onShouldRetry","chunkSize","Infinity","retryDelays","parallelUploads","storeFingerprintForResuming","removeFingerprintOnSuccess","uploadLengthDeferred","uploadDataDuringCreation","urlStorage","fileReader","httpStack","BaseUpload","file","options","console","_urlStorage","url","_req","_fingerprint","_urlStorageKey","_offset","_aborted","_size","_source","_retryAttempt","_retryTimeout","_offsetBeforeRetry","_parallelUploads","_parallelUploadUrls","findPreviousUploads","_this","then","findUploadsByFingerprint","resumeFromPreviousUpload","previousUpload","parallelUploadUrls","urlStorageKey","start","_this2","_emitError","Error","toString","call","optionName","concat","openFile","_startParallelUpload","_startSingleUpload","err","_this3","totalSize","size","totalProgress","partCount","parts","splitSizeIntoParts","Array","uploads","map","part","index","lastPartProgress","slice","end","_ref","Promise","resolve","reject","newPartProgress","_emitProgress","upload","u","_saveUploadInUrlStorage","req","all","_openRequest","setHeader","join","encodeMetadata","_sendRequest","res","inStatusCategory","getStatus","_emitHttpError","location","getHeader","resolveUrl","_emitSuccess","isNaN","_resumeUpload","_createUpload","abort","shouldTerminate","_this4","close","clearTimeout","terminate","_removeFromUrlStorage","message","causingErr","_this5","shouldResetDelays","shouldRetry","delay","setTimeout","bytesSent","bytesTotal","_emitChunkComplete","bytesAccepted","_this6","promise","_addChunkToRequest","_handleUploadResponse","_performUpload","_this7","status","offset","parseInt","_this8","_this9","setProgressHandler","_ref2","done","method","openRequest","_this10","removeUpload","_this11","storedUpload","creationTime","Date","addUpload","body","undefined","sendRequest","remainingDelays","newOptions","encoded","encode","category","createRequest","name","requestId","onBeforeRequestPromise","send","onAfterResponsePromise","isOnline","online","window","navigator","onLine","retryAttempt","originalRequest","originalResponse","origin","link","previousUrls","partSize","Math","floor"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* global window */\nimport { Base64 } from 'js-base64';\nimport URL from 'url-parse';\nimport DetailedError from './error';\nimport { log } from './logger';\nimport uuid from './uuid';\nvar defaultOptions = {\n  endpoint: null,\n  uploadUrl: null,\n  metadata: {},\n  fingerprint: null,\n  uploadSize: null,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  _onUploadUrlAvailable: null,\n  overridePatchMethod: false,\n  headers: {},\n  addRequestId: false,\n  onBeforeRequest: null,\n  onAfterResponse: null,\n  onShouldRetry: null,\n  chunkSize: Infinity,\n  retryDelays: [0, 1000, 3000, 5000],\n  parallelUploads: 1,\n  storeFingerprintForResuming: true,\n  removeFingerprintOnSuccess: false,\n  uploadLengthDeferred: false,\n  uploadDataDuringCreation: false,\n  urlStorage: null,\n  fileReader: null,\n  httpStack: null\n};\n\nvar BaseUpload = /*#__PURE__*/function () {\n  function BaseUpload(file, options) {\n    _classCallCheck(this, BaseUpload);\n\n    // Warn about removed options from previous versions\n    if ('resume' in options) {\n      console.log('tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.'); // eslint-disable-line no-console\n    } // The default options will already be added from the wrapper classes.\n\n\n    this.options = options; // The storage module used to store URLs\n\n    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object\n\n    this.file = file; // The URL against which the file will be uploaded\n\n    this.url = null; // The underlying request object for the current PATCH request\n\n    this._req = null; // The fingerpinrt for the current file (set after start())\n\n    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,\n\n    this._urlStorageKey = null; // The offset used in the current PATCH request\n\n    this._offset = null; // True if the current PATCH request has been aborted\n\n    this._aborted = false; // The file's size in bytes\n\n    this._size = null; // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n\n    this._source = null; // The current count of attempts which have been made. Zero indicates none.\n\n    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry\n\n    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.\n\n    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different\n    // parts, if the parallelUploads option is used.\n\n    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different\n    // parts, if the parallelUploads option is used.\n\n    this._parallelUploadUrls = null;\n  }\n  /**\n   * Use the Termination extension to delete an upload from the server by sending a DELETE\n   * request to the specified upload URL. This is only possible if the server supports the\n   * Termination extension. If the `options.retryDelays` property is set, the method will\n   * also retry if an error ocurrs.\n   *\n   * @param {String} url The upload's URL which will be terminated.\n   * @param {object} options Optional options for influencing HTTP requests.\n   * @return {Promise} The Promise will be resolved/rejected when the requests finish.\n   */\n\n\n  _createClass(BaseUpload, [{\n    key: \"findPreviousUploads\",\n    value: function findPreviousUploads() {\n      var _this = this;\n\n      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {\n        return _this._urlStorage.findUploadsByFingerprint(fingerprint);\n      });\n    }\n  }, {\n    key: \"resumeFromPreviousUpload\",\n    value: function resumeFromPreviousUpload(previousUpload) {\n      this.url = previousUpload.uploadUrl || null;\n      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;\n      this._urlStorageKey = previousUpload.urlStorageKey;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n\n      var file = this.file;\n\n      if (!file) {\n        this._emitError(new Error('tus: no file or stream to upload provided'));\n\n        return;\n      }\n\n      if (!this.options.endpoint && !this.options.uploadUrl) {\n        this._emitError(new Error('tus: neither an endpoint or an upload URL is provided'));\n\n        return;\n      }\n\n      var retryDelays = this.options.retryDelays;\n\n      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== '[object Array]') {\n        this._emitError(new Error('tus: the `retryDelays` option must either be an array or null'));\n\n        return;\n      }\n\n      if (this.options.parallelUploads > 1) {\n        // Test which options are incompatible with parallel uploads.\n        ['uploadUrl', 'uploadSize', 'uploadLengthDeferred'].forEach(function (optionName) {\n          if (_this2.options[optionName]) {\n            _this2._emitError(new Error(\"tus: cannot use the \".concat(optionName, \" option when parallelUploads is enabled\")));\n          }\n        });\n      }\n\n      this.options.fingerprint(file, this.options).then(function (fingerprint) {\n        if (fingerprint == null) {\n          log('No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.');\n        } else {\n          log(\"Calculated fingerprint: \".concat(fingerprint));\n        }\n\n        _this2._fingerprint = fingerprint;\n\n        if (_this2._source) {\n          return _this2._source;\n        }\n\n        return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);\n      }).then(function (source) {\n        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from\n        // an upload which used multiple requests, we start a parallel upload.\n\n        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {\n          _this2._startParallelUpload();\n        } else {\n          _this2._startSingleUpload();\n        }\n      })[\"catch\"](function (err) {\n        _this2._emitError(err);\n      });\n    }\n    /**\n     * Initiate the uploading procedure for a parallelized upload, where one file is split into\n     * multiple request which are run in parallel.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_startParallelUpload\",\n    value: function _startParallelUpload() {\n      var _this3 = this;\n\n      var totalSize = this._size = this._source.size;\n      var totalProgress = 0;\n      this._parallelUploads = [];\n      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate\n      // requests. Here we generate the start and end position for the slices.\n\n      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs\n\n      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective\n      // upload is completed.\n\n      var uploads = parts.map(function (part, index) {\n        var lastPartProgress = 0;\n        return _this3._source.slice(part.start, part.end).then(function (_ref) {\n          var value = _ref.value;\n          return new Promise(function (resolve, reject) {\n            // Merge with the user supplied options but overwrite some values.\n            var options = _objectSpread({}, _this3.options, {\n              // If available, the partial upload should be resumed from a previous URL.\n              uploadUrl: part.uploadUrl || null,\n              // We take manually care of resuming for partial uploads, so they should\n              // not be stored in the URL storage.\n              storeFingerprintForResuming: false,\n              removeFingerprintOnSuccess: false,\n              // Reset the parallelUploads option to not cause recursion.\n              parallelUploads: 1,\n              metadata: {},\n              // Add the header to indicate the this is a partial upload.\n              headers: _objectSpread({}, _this3.options.headers, {\n                'Upload-Concat': 'partial'\n              }),\n              // Reject or resolve the promise if the upload errors or completes.\n              onSuccess: resolve,\n              onError: reject,\n              // Based in the progress for this partial upload, calculate the progress\n              // for the entire final upload.\n              onProgress: function onProgress(newPartProgress) {\n                totalProgress = totalProgress - lastPartProgress + newPartProgress;\n                lastPartProgress = newPartProgress;\n\n                _this3._emitProgress(totalProgress, totalSize);\n              },\n              // Wait until every partial upload has an upload URL, so we can add\n              // them to the URL storage.\n              _onUploadUrlAvailable: function _onUploadUrlAvailable() {\n                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL\n\n                if (_this3._parallelUploadUrls.filter(function (u) {\n                  return !!u;\n                }).length === parts.length) {\n                  _this3._saveUploadInUrlStorage();\n                }\n              }\n            });\n\n            var upload = new BaseUpload(value, options);\n            upload.start(); // Store the upload in an array, so we can later abort them if necessary.\n\n            _this3._parallelUploads.push(upload);\n          });\n        });\n      });\n      var req; // Wait until all partial uploads are finished and we can send the POST request for\n      // creating the final upload.\n\n      Promise.all(uploads).then(function () {\n        req = _this3._openRequest('POST', _this3.options.endpoint);\n        req.setHeader('Upload-Concat', \"final;\".concat(_this3._parallelUploadUrls.join(' '))); // Add metadata if values have been added\n\n        var metadata = encodeMetadata(_this3.options.metadata);\n\n        if (metadata !== '') {\n          req.setHeader('Upload-Metadata', metadata);\n        }\n\n        return _this3._sendRequest(req, null);\n      }).then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this3._emitHttpError(req, res, 'tus: unexpected response while creating upload');\n\n          return;\n        }\n\n        var location = res.getHeader('Location');\n\n        if (location == null) {\n          _this3._emitHttpError(req, res, 'tus: invalid or missing Location header');\n\n          return;\n        }\n\n        _this3.url = resolveUrl(_this3.options.endpoint, location);\n        log(\"Created upload at \".concat(_this3.url));\n\n        _this3._emitSuccess();\n      })[\"catch\"](function (err) {\n        _this3._emitError(err);\n      });\n    }\n    /**\n     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is\n     * uploaded in a sequential matter.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_startSingleUpload\",\n    value: function _startSingleUpload() {\n      // First, we look at the uploadLengthDeferred option.\n      // Next, we check if the caller has supplied a manual upload size.\n      // Finally, we try to use the calculated size from the source object.\n      if (this.options.uploadLengthDeferred) {\n        this._size = null;\n      } else if (this.options.uploadSize != null) {\n        this._size = +this.options.uploadSize;\n\n        if (isNaN(this._size)) {\n          this._emitError(new Error('tus: cannot convert `uploadSize` option into a number'));\n\n          return;\n        }\n      } else {\n        this._size = this._source.size;\n\n        if (this._size == null) {\n          this._emitError(new Error(\"tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option\"));\n\n          return;\n        }\n      } // Reset the aborted flag when the upload is started or else the\n      // _performUpload will stop before sending a request if the upload has been\n      // aborted previously.\n\n\n      this._aborted = false; // The upload had been started previously and we should reuse this URL.\n\n      if (this.url != null) {\n        log(\"Resuming upload from previous URL: \".concat(this.url));\n\n        this._resumeUpload();\n\n        return;\n      } // A URL has manually been specified, so we try to resume\n\n\n      if (this.options.uploadUrl != null) {\n        log(\"Resuming upload from provided URL: \".concat(this.options.url));\n        this.url = this.options.uploadUrl;\n\n        this._resumeUpload();\n\n        return;\n      } // An upload has not started for the file yet, so we start a new one\n\n\n      log('Creating a new upload');\n\n      this._createUpload();\n    }\n    /**\n     * Abort any running request and stop the current upload. After abort is called, no event\n     * handler will be invoked anymore. You can use the `start` method to resume the upload\n     * again.\n     * If `shouldTerminate` is true, the `terminate` function will be called to remove the\n     * current upload from the server.\n     *\n     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.\n     * @return {Promise} The Promise will be resolved/rejected when the requests finish.\n     */\n\n  }, {\n    key: \"abort\",\n    value: function abort(shouldTerminate) {\n      var _this4 = this;\n\n      // Count the number of arguments to see if a callback is being provided in the old style required by tus-js-client 1.x, then throw an error if it is.\n      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.\n      if (arguments.length > 1 && typeof arguments[1] === 'function') {\n        throw new Error('tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead');\n      } // Stop any parallel partial uploads, that have been started in _startParallelUploads.\n\n\n      if (this._parallelUploads != null) {\n        this._parallelUploads.forEach(function (upload) {\n          upload.abort(shouldTerminate);\n        });\n      } // Stop any current running request.\n\n\n      if (this._req !== null) {\n        this._req.abort();\n\n        this._source.close();\n      }\n\n      this._aborted = true; // Stop any timeout used for initiating a retry.\n\n      if (this._retryTimeout != null) {\n        clearTimeout(this._retryTimeout);\n        this._retryTimeout = null;\n      }\n\n      if (!shouldTerminate || this.url == null) {\n        return Promise.resolve();\n      }\n\n      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.\n      .then(function () {\n        return _this4._removeFromUrlStorage();\n      });\n    }\n  }, {\n    key: \"_emitHttpError\",\n    value: function _emitHttpError(req, res, message, causingErr) {\n      this._emitError(new DetailedError(message, causingErr, req, res));\n    }\n  }, {\n    key: \"_emitError\",\n    value: function _emitError(err) {\n      var _this5 = this;\n\n      // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.\n      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.\n\n      if (this.options.retryDelays != null) {\n        // We will reset the attempt counter if\n        // - we were already able to connect to the server (offset != null) and\n        // - we were able to upload a small chunk of data to the server\n        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;\n\n        if (shouldResetDelays) {\n          this._retryAttempt = 0;\n        }\n\n        if (shouldRetry(err, this._retryAttempt, this.options)) {\n          var delay = this.options.retryDelays[this._retryAttempt++];\n          this._offsetBeforeRetry = this._offset;\n          this._retryTimeout = setTimeout(function () {\n            _this5.start();\n          }, delay);\n          return;\n        }\n      }\n\n      if (typeof this.options.onError === 'function') {\n        this.options.onError(err);\n      } else {\n        throw err;\n      }\n    }\n    /**\n     * Publishes notification if the upload has been successfully completed.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_emitSuccess\",\n    value: function _emitSuccess() {\n      if (this.options.removeFingerprintOnSuccess) {\n        // Remove stored fingerprint and corresponding endpoint. This causes\n        // new uploads of the same file to be treated as a different file.\n        this._removeFromUrlStorage();\n      }\n\n      if (typeof this.options.onSuccess === 'function') {\n        this.options.onSuccess();\n      }\n    }\n    /**\n     * Publishes notification when data has been sent to the server. This\n     * data may not have been accepted by the server yet.\n     *\n     * @param {number} bytesSent  Number of bytes sent to the server.\n     * @param {number} bytesTotal Total number of bytes to be sent to the server.\n     * @api private\n     */\n\n  }, {\n    key: \"_emitProgress\",\n    value: function _emitProgress(bytesSent, bytesTotal) {\n      if (typeof this.options.onProgress === 'function') {\n        this.options.onProgress(bytesSent, bytesTotal);\n      }\n    }\n    /**\n     * Publishes notification when a chunk of data has been sent to the server\n     * and accepted by the server.\n     * @param {number} chunkSize  Size of the chunk that was accepted by the server.\n     * @param {number} bytesAccepted Total number of bytes that have been\n     *                                accepted by the server.\n     * @param {number} bytesTotal Total number of bytes to be sent to the server.\n     * @api private\n     */\n\n  }, {\n    key: \"_emitChunkComplete\",\n    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n      if (typeof this.options.onChunkComplete === 'function') {\n        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n      }\n    }\n    /**\n     * Create a new upload using the creation extension by sending a POST\n     * request to the endpoint. After successful creation the file will be\n     * uploaded\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_createUpload\",\n    value: function _createUpload() {\n      var _this6 = this;\n\n      if (!this.options.endpoint) {\n        this._emitError(new Error('tus: unable to create upload because no endpoint is provided'));\n\n        return;\n      }\n\n      var req = this._openRequest('POST', this.options.endpoint);\n\n      if (this.options.uploadLengthDeferred) {\n        req.setHeader('Upload-Defer-Length', 1);\n      } else {\n        req.setHeader('Upload-Length', this._size);\n      } // Add metadata if values have been added\n\n\n      var metadata = encodeMetadata(this.options.metadata);\n\n      if (metadata !== '') {\n        req.setHeader('Upload-Metadata', metadata);\n      }\n\n      var promise;\n\n      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {\n        this._offset = 0;\n        promise = this._addChunkToRequest(req);\n      } else {\n        promise = this._sendRequest(req, null);\n      }\n\n      promise.then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this6._emitHttpError(req, res, 'tus: unexpected response while creating upload');\n\n          return;\n        }\n\n        var location = res.getHeader('Location');\n\n        if (location == null) {\n          _this6._emitHttpError(req, res, 'tus: invalid or missing Location header');\n\n          return;\n        }\n\n        _this6.url = resolveUrl(_this6.options.endpoint, location);\n        log(\"Created upload at \".concat(_this6.url));\n\n        if (typeof _this6.options._onUploadUrlAvailable === 'function') {\n          _this6.options._onUploadUrlAvailable();\n        }\n\n        if (_this6._size === 0) {\n          // Nothing to upload and file was successfully created\n          _this6._emitSuccess();\n\n          _this6._source.close();\n\n          return;\n        }\n\n        _this6._saveUploadInUrlStorage();\n\n        if (_this6.options.uploadDataDuringCreation) {\n          _this6._handleUploadResponse(req, res);\n        } else {\n          _this6._offset = 0;\n\n          _this6._performUpload();\n        }\n      })[\"catch\"](function (err) {\n        _this6._emitHttpError(req, null, 'tus: failed to create upload', err);\n      });\n    }\n    /*\n     * Try to resume an existing upload. First a HEAD request will be sent\n     * to retrieve the offset. If the request fails a new upload will be\n     * created. In the case of a successful response the file will be uploaded.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_resumeUpload\",\n    value: function _resumeUpload() {\n      var _this7 = this;\n\n      var req = this._openRequest('HEAD', this.url);\n\n      var promise = this._sendRequest(req, null);\n\n      promise.then(function (res) {\n        var status = res.getStatus();\n\n        if (!inStatusCategory(status, 200)) {\n          if (inStatusCategory(status, 400)) {\n            // Remove stored fingerprint and corresponding endpoint,\n            // on client errors since the file can not be found\n            _this7._removeFromUrlStorage();\n          } // If the upload is locked (indicated by the 423 Locked status code), we\n          // emit an error instead of directly starting a new upload. This way the\n          // retry logic can catch the error and will retry the upload. An upload\n          // is usually locked for a short period of time and will be available\n          // afterwards.\n\n\n          if (status === 423) {\n            _this7._emitHttpError(req, res, 'tus: upload is currently locked; retry later');\n\n            return;\n          }\n\n          if (!_this7.options.endpoint) {\n            // Don't attempt to create a new upload if no endpoint is provided.\n            _this7._emitHttpError(req, res, 'tus: unable to resume upload (new upload cannot be created without an endpoint)');\n\n            return;\n          } // Try to create a new upload\n\n\n          _this7.url = null;\n\n          _this7._createUpload();\n\n          return;\n        }\n\n        var offset = parseInt(res.getHeader('Upload-Offset'), 10);\n\n        if (isNaN(offset)) {\n          _this7._emitHttpError(req, res, 'tus: invalid or missing offset value');\n\n          return;\n        }\n\n        var length = parseInt(res.getHeader('Upload-Length'), 10);\n\n        if (isNaN(length) && !_this7.options.uploadLengthDeferred) {\n          _this7._emitHttpError(req, res, 'tus: invalid or missing length value');\n\n          return;\n        }\n\n        if (typeof _this7.options._onUploadUrlAvailable === 'function') {\n          _this7.options._onUploadUrlAvailable();\n        } // Upload has already been completed and we do not need to send additional\n        // data to the server\n\n\n        if (offset === length) {\n          _this7._emitProgress(length, length);\n\n          _this7._emitSuccess();\n\n          return;\n        }\n\n        _this7._offset = offset;\n\n        _this7._performUpload();\n      })[\"catch\"](function (err) {\n        _this7._emitHttpError(req, null, 'tus: failed to resume upload', err);\n      });\n    }\n    /**\n     * Start uploading the file using PATCH requests. The file will be divided\n     * into chunks as specified in the chunkSize option. During the upload\n     * the onProgress event handler may be invoked multiple times.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_performUpload\",\n    value: function _performUpload() {\n      var _this8 = this;\n\n      // If the upload has been aborted, we will not send the next PATCH request.\n      // This is important if the abort method was called during a callback, such\n      // as onChunkComplete or onProgress.\n      if (this._aborted) {\n        return;\n      }\n\n      var req; // Some browser and servers may not support the PATCH method. For those\n      // cases, you can tell tus-js-client to use a POST request with the\n      // X-HTTP-Method-Override header for simulating a PATCH request.\n\n      if (this.options.overridePatchMethod) {\n        req = this._openRequest('POST', this.url);\n        req.setHeader('X-HTTP-Method-Override', 'PATCH');\n      } else {\n        req = this._openRequest('PATCH', this.url);\n      }\n\n      req.setHeader('Upload-Offset', this._offset);\n\n      var promise = this._addChunkToRequest(req);\n\n      promise.then(function (res) {\n        if (!inStatusCategory(res.getStatus(), 200)) {\n          _this8._emitHttpError(req, res, 'tus: unexpected response while uploading chunk');\n\n          return;\n        }\n\n        _this8._handleUploadResponse(req, res);\n      })[\"catch\"](function (err) {\n        // Don't emit an error if the upload was aborted manually\n        if (_this8._aborted) {\n          return;\n        }\n\n        _this8._emitHttpError(req, null, \"tus: failed to upload chunk at offset \".concat(_this8._offset), err);\n      });\n    }\n    /**\n     * _addChunktoRequest reads a chunk from the source and sends it using the\n     * supplied request object. It will not handle the response.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_addChunkToRequest\",\n    value: function _addChunkToRequest(req) {\n      var _this9 = this;\n\n      var start = this._offset;\n      var end = this._offset + this.options.chunkSize;\n      req.setProgressHandler(function (bytesSent) {\n        _this9._emitProgress(start + bytesSent, _this9._size);\n      });\n      req.setHeader('Content-Type', 'application/offset+octet-stream'); // The specified chunkSize may be Infinity or the calcluated end position\n      // may exceed the file's size. In both cases, we limit the end position to\n      // the input's total size for simpler calculations and correctness.\n\n      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {\n        end = this._size;\n      }\n\n      return this._source.slice(start, end).then(function (_ref2) {\n        var value = _ref2.value,\n            done = _ref2.done;\n\n        // If the upload length is deferred, the upload size was not specified during\n        // upload creation. So, if the file reader is done reading, we know the total\n        // upload size and can tell the tus server.\n        if (_this9.options.uploadLengthDeferred && done) {\n          _this9._size = _this9._offset + (value && value.size ? value.size : 0);\n          req.setHeader('Upload-Length', _this9._size);\n        }\n\n        if (value === null) {\n          return _this9._sendRequest(req);\n        }\n\n        _this9._emitProgress(_this9._offset, _this9._size);\n\n        return _this9._sendRequest(req, value);\n      });\n    }\n    /**\n     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest\n     * and already have received a response.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_handleUploadResponse\",\n    value: function _handleUploadResponse(req, res) {\n      var offset = parseInt(res.getHeader('Upload-Offset'), 10);\n\n      if (isNaN(offset)) {\n        this._emitHttpError(req, res, 'tus: invalid or missing offset value');\n\n        return;\n      }\n\n      this._emitProgress(offset, this._size);\n\n      this._emitChunkComplete(offset - this._offset, offset, this._size);\n\n      this._offset = offset;\n\n      if (offset == this._size) {\n        // Yay, finally done :)\n        this._emitSuccess();\n\n        this._source.close();\n\n        return;\n      }\n\n      this._performUpload();\n    }\n    /**\n     * Create a new HTTP request object with the given method and URL.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_openRequest\",\n    value: function _openRequest(method, url) {\n      var req = openRequest(method, url, this.options);\n      this._req = req;\n      return req;\n    }\n    /**\n     * Remove the entry in the URL storage, if it has been saved before.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_removeFromUrlStorage\",\n    value: function _removeFromUrlStorage() {\n      var _this10 = this;\n\n      if (!this._urlStorageKey) return;\n\n      this._urlStorage.removeUpload(this._urlStorageKey)[\"catch\"](function (err) {\n        _this10._emitError(err);\n      });\n\n      this._urlStorageKey = null;\n    }\n    /**\n     * Add the upload URL to the URL storage, if possible.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_saveUploadInUrlStorage\",\n    value: function _saveUploadInUrlStorage() {\n      var _this11 = this;\n\n      // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.\n      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {\n        return;\n      }\n\n      var storedUpload = {\n        size: this._size,\n        metadata: this.options.metadata,\n        creationTime: new Date().toString()\n      };\n\n      if (this._parallelUploads) {\n        // Save multiple URLs if the parallelUploads option is used ...\n        storedUpload.parallelUploadUrls = this._parallelUploadUrls;\n      } else {\n        // ... otherwise we just save the one available URL.\n        storedUpload.uploadUrl = this.url;\n      }\n\n      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {\n        return _this11._urlStorageKey = urlStorageKey;\n      })[\"catch\"](function (err) {\n        _this11._emitError(err);\n      });\n    }\n    /**\n     * Send a request with the provided body.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"_sendRequest\",\n    value: function _sendRequest(req) {\n      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return sendRequest(req, body, this.options);\n    }\n  }], [{\n    key: \"terminate\",\n    value: function terminate(url, options) {\n      // Count the number of arguments to see if a callback is being provided as the last\n      // argument in the old style required by tus-js-client 1.x, then throw an error if it is.\n      // `arguments` is a JavaScript built-in variable that contains all of the function's arguments.\n      if (arguments.length > 1 && typeof arguments[arguments.length - 1] === 'function') {\n        throw new Error('tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead');\n      } // Note that in order for the trick above to work, a default value cannot be set for `options`,\n      // so the check below replaces the old default `{}`.\n\n\n      if (options === undefined) {\n        options = {};\n      }\n\n      var req = openRequest('DELETE', url, options);\n      return sendRequest(req, null, options).then(function (res) {\n        // A 204 response indicates a successfull request\n        if (res.getStatus() === 204) {\n          return;\n        }\n\n        throw new DetailedError('tus: unexpected response while terminating upload', null, req, res);\n      })[\"catch\"](function (err) {\n        if (!(err instanceof DetailedError)) {\n          err = new DetailedError('tus: failed to terminate upload', err, req, null);\n        }\n\n        if (!shouldRetry(err, 0, options)) {\n          throw err;\n        } // Instead of keeping track of the retry attempts, we remove the first element from the delays\n        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.\n        // We recursively call the terminate function will removing elements from the retryDelays array.\n\n\n        var delay = options.retryDelays[0];\n        var remainingDelays = options.retryDelays.slice(1);\n\n        var newOptions = _objectSpread({}, options, {\n          retryDelays: remainingDelays\n        });\n\n        return new Promise(function (resolve) {\n          return setTimeout(resolve, delay);\n        }).then(function () {\n          return BaseUpload.terminate(url, newOptions);\n        });\n      });\n    }\n  }]);\n\n  return BaseUpload;\n}();\n\nfunction encodeMetadata(metadata) {\n  var encoded = [];\n\n  for (var key in metadata) {\n    encoded.push(\"\".concat(key, \" \").concat(Base64.encode(metadata[key])));\n  }\n\n  return encoded.join(',');\n}\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\n\n\nfunction inStatusCategory(status, category) {\n  return status >= category && status < category + 100;\n}\n/**\n * Create a new HTTP request with the specified method and URL.\n * The necessary headers that are included in every request\n * will be added, including the request ID.\n *\n * @api private\n */\n\n\nfunction openRequest(method, url, options) {\n  var req = options.httpStack.createRequest(method, url);\n  req.setHeader('Tus-Resumable', '1.0.0');\n  var headers = options.headers || {};\n\n  for (var name in headers) {\n    req.setHeader(name, headers[name]);\n  }\n\n  if (options.addRequestId) {\n    var requestId = uuid();\n    req.setHeader('X-Request-ID', requestId);\n  }\n\n  return req;\n}\n/**\n * Send a request with the provided body while invoking the onBeforeRequest\n * and onAfterResponse callbacks.\n *\n * @api private\n */\n\n\nfunction sendRequest(req, body, options) {\n  var onBeforeRequestPromise = typeof options.onBeforeRequest === 'function' ? Promise.resolve(options.onBeforeRequest(req)) : Promise.resolve();\n  return onBeforeRequestPromise.then(function () {\n    return req.send(body).then(function (res) {\n      var onAfterResponsePromise = typeof options.onAfterResponse === 'function' ? Promise.resolve(options.onAfterResponse(req, res)) : Promise.resolve();\n      return onAfterResponsePromise.then(function () {\n        return res;\n      });\n    });\n  });\n}\n/**\n * Checks whether the browser running this code has internet access.\n * This function will always return true in the node.js environment\n *\n * @api private\n */\n\n\nfunction isOnline() {\n  var online = true;\n\n  if (typeof window !== 'undefined' && 'navigator' in window && window.navigator.onLine === false) {\n    online = false;\n  }\n\n  return online;\n}\n/**\n * Checks whether or not it is ok to retry a request.\n * @param {Error} err the error returned from the last request\n * @param {number} retryAttempt the number of times the request has already been retried\n * @param {object} options tus Upload options\n *\n * @api private\n */\n\n\nfunction shouldRetry(err, retryAttempt, options) {\n  // We only attempt a retry if\n  // - retryDelays option is set\n  // - we didn't exceed the maxium number of retries, yet, and\n  // - this error was caused by a request or it's response and\n  // - the error is server error (i.e. not a status 4xx except a 409 or 423) or\n  // a onShouldRetry is specified and returns true\n  // - the browser does not indicate that we are offline\n  if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {\n    return false;\n  }\n\n  if (options && typeof options.onShouldRetry === 'function') {\n    return options.onShouldRetry(err, retryAttempt, options);\n  }\n\n  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;\n  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline();\n}\n/**\n * Resolve a relative link given the origin as source. For example,\n * if a HTTP request to http://example.com/files/ returns a Location\n * header with the value /upload/abc, the resolved URL will be:\n * http://example.com/upload/abc\n */\n\n\nfunction resolveUrl(origin, link) {\n  return new URL(link, origin).toString();\n}\n/**\n * Calculate the start and end positions for the parts if an upload\n * is split into multiple parallel requests.\n *\n * @param {number} totalSize The byte size of the upload, which will be split.\n * @param {number} partCount The number in how many parts the upload will be split.\n * @param {string[]} previousUrls The upload URLs for previous parts.\n * @return {object[]}\n * @api private\n */\n\n\nfunction splitSizeIntoParts(totalSize, partCount, previousUrls) {\n  var partSize = Math.floor(totalSize / partCount);\n  var parts = [];\n\n  for (var i = 0; i < partCount; i++) {\n    parts.push({\n      start: partSize * i,\n      end: partSize * (i + 1)\n    });\n  }\n\n  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.\n\n  if (previousUrls) {\n    parts.forEach(function (part, index) {\n      part.uploadUrl = previousUrls[index] || null;\n    });\n  }\n\n  return parts;\n}\n\nBaseUpload.defaultOptions = defaultOptions;\nexport default BaseUpload;"]},"metadata":{},"sourceType":"module"}